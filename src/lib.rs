use std::path::Path;
#[cfg(feature="serde")]
use serde::Serialize;
#[cfg(feature="xml")]
use plist::{to_writer_xml, to_file_xml};

/// Representation of a launchd.plist file.
/// The definition of which can be found [here](https://www.manpagez.com/man/5/launchd.plist/).
/// 
/// Usage:
/// ```
/// use launchd::{Launchd, LaunchdError, CalendarInterval};
/// use std::path::Path;
/// 
/// fn example() -> Result<Launchd, LaunchdError> {
///     Ok(Launchd::new(String::from("LABEL"), Path::new("./foo/bar.txt"))
///         ?.with_user_name("Henk".to_owned())
///         .with_program_arguments(vec!["Hello".to_owned(), "World!".to_owned()])
///         .with_start_calendar_intervals(vec![CalendarInterval::new().with_hour(12)?])
///         // etc...
///     )
/// }
/// 
/// let launchd = example();
///     
/// ```
/// This will create a launchd representation with the label "LABEL", running "./foo/bar.txt" 
/// with the args "Hello" and "World!", for the user "Henk", each day at 12.
/// 
/// NB: The usage is still subject to change.
// TODO: Fill with all options in https://www.manpagez.com/man/5/launchd.plist/
// TODO: remove owning Strings
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "xml", serde(rename_all = "PascalCase"))]
pub struct Launchd {
    label: String,
    disabled: Option<bool>,
    user_name: Option<String>,
    group_name: Option<String>,
    // inetdCompatibility: Option<(?)>,
    // LimitLoadToHosts: Option<Vec<String>>,
    // LimitLoadFromHosts: Option<Vec<String>>,
    // LimitLoadToSessionType: Option<String>,
    program: String,
    program_arguments: Option<Vec<String>>,
    // EnableGlobbing: Option<bool>,
    // EnableTransactions: Option<bool>,
    // OnDemand: Option<bool>, NB: deprecated (see KeepAlive)
    // KeepAlive: Option<(?)>,
    run_at_load: Option<bool>,
    // RootDirectory: Option<String>, NB: from path
    // WorkingDirectory: Option<String>, NB: from path
    // EnvironmentVariables: Option<String>
    // Unmask: Option<u32> NB: check mode_t size in <sys/types.h>
    // TimeOut: Option<u32>
    // ExitTimeOut: Option<u32>
    // ThrottleInterval: Option<u32>
    // InitGroups: Option<bool>
    watch_paths: Option<Vec<String>>,
    queue_directories: Option<Vec<String>>,
    start_on_mount: Option<bool>,
    start_interval: Option<u32>,
    start_calendar_intervals: Option<Vec<CalendarInterval>>,
    // StandardInPath: Option<String> NB: from path
    // StandardOutPath: Option<String> NB: from path
    // StandardErrorPath: Option<String> NB: from path
    // ...
}

#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "xml", serde(rename_all = "PascalCase"))]
pub struct CalendarInterval {
    minute: Option<u8>,
    hour: Option<u8>,
    day: Option<u8>,
    weekday: Option<u8>,
    month: Option<u8>,
}

// TODO implement debug
#[derive(Debug)]
pub enum LaunchdError {
    CalendarIntervalError(CalendarIntervalField, u8),
    PathConversionError,
}

#[derive(Debug)]
pub enum CalendarIntervalField {
    Minute,
    Hour,
    Day,
    Weekday,
    Month,
}

// TODO: This can be generated by a macro (maybe derive_builder?)
impl Launchd {
    pub fn new(label: String, program: &Path) -> Result<Self, LaunchdError> {
        let pathstr = program.to_str().ok_or(LaunchdError::PathConversionError)?.to_owned();
        Ok(Launchd {
            label: label,
            disabled: None,
            user_name: None,
            group_name: None,
            program: pathstr,
            program_arguments: None,
            run_at_load: None,
            watch_paths: None,
            queue_directories: None,
            start_on_mount: None,
            start_interval: None,
            start_calendar_intervals: None,
        })
    }

    pub fn with_label(mut self, label: String) -> Self {
        self.label = label;
        self
    }

    pub fn with_disabled(mut self, disabled: bool) -> Self{
        self.disabled = Some(disabled);
        self
    }

    pub fn disabled(self) -> Self {
        self.with_disabled(true)
    }

   pub fn with_user_name(mut self, user_name: String) -> Self {
       self.user_name = Some(user_name);
       self
   }

   pub fn with_group_name(mut self, group_name: String) -> Self {
       self.group_name = Some(group_name);
       self
   }

   pub fn with_program(mut self, program: &Path) -> Result<Self, LaunchdError> {
       let pathstr = program.to_str().ok_or(LaunchdError::PathConversionError)?.to_owned();
       self.program = pathstr;
       Ok(self)
   }

    pub fn with_program_arguments(mut self, program_arguments: Vec<String>) -> Self {
        self.program_arguments = Some(program_arguments);
        self
    }

    pub fn run_at_load(mut self) -> Self {
        self.run_at_load = Some(true);
        self
    }

    pub fn with_run_at_load(mut self, run_at_load: bool) -> Self {
        self.run_at_load = Some(run_at_load);
        self
    }

    pub fn with_queue_directories(
        mut self, 
        queue_directories: Vec<String>
    ) -> Self {
        self.queue_directories = Some(queue_directories);
        self
    }

    pub fn with_watch_paths(mut self, watch_paths: Vec<String>) -> Self {
        self.watch_paths = Some(watch_paths);
        self
    }

    pub fn with_start_on_mount(mut self, start_on_mount: bool) -> Self {
        self.start_on_mount = Some(start_on_mount);
        self
    }

    pub fn start_on_mount(self) -> Self {
        self.with_start_on_mount(true)
    }

    pub fn with_start_interval(mut self, start_interval: u32) -> Self {
        self.start_interval = Some(start_interval);
        self
    }

    pub fn with_start_calendar_intervals(mut self, start_calendar_intervals: Vec<CalendarInterval>) -> Self {
        self.start_calendar_intervals = Some(start_calendar_intervals);
        self
    }

    // Write --
    #[cfg(feature="xml")]
    pub fn to_writer_xml<W: std::io::Write>(&self, writer: W) -> Result<(), plist::Error>{
        to_writer_xml(writer, self)
    }

    #[cfg(feature="xml")]
    pub fn to_file_xml<P: AsRef<Path>>(&self, file: P) -> Result<(), plist::Error>{
        to_file_xml(file, self)
    }
}

/// Representation of a CalendarInterval
/// 
/// Usage:
/// ```
/// use launchd::{CalendarInterval, LaunchdError};
/// fn example() -> Result<CalendarInterval, LaunchdError> {
///     CalendarInterval::new()
///             .with_hour(12)
///             ?.with_minute(10)
///             ?.with_weekday(7)
/// }
/// 
/// let calendarinterval = example();
/// ```
/// 
impl CalendarInterval {
    pub fn new() -> Self {
        CalendarInterval {
            minute: None,
            hour: None,
            day: None,
            weekday: None,
            month: None,
        }
    }

    pub fn with_minute(mut self, minute: u8) -> Result<Self, LaunchdError> {
        return if minute > 60 {
            Err(LaunchdError::CalendarIntervalError(CalendarIntervalField::Minute, minute))
        } else {
            self.minute = Some(minute);
            Ok(self)
        }
    }

    pub fn with_hour(mut self, hour: u8) -> Result<Self, LaunchdError> {
        return if hour > 60 {
            Err(LaunchdError::CalendarIntervalError(CalendarIntervalField::Hour, hour))
        } else {
            self.hour = Some(hour);
            Ok(self)
        }
    }

    pub fn with_day(mut self, day: u8) -> Result<Self, LaunchdError> {
        return if day > 31 {
            Err(LaunchdError::CalendarIntervalError(CalendarIntervalField::Day, day))
        } else {
            self.day = Some(day);
            Ok(self)
        }
    }

    pub fn with_weekday(mut self, weekday: u8) -> Result<Self, LaunchdError> {
        return if weekday > 7 {
            Err(LaunchdError::CalendarIntervalError(CalendarIntervalField::Weekday, weekday))
        } else {
            self.weekday = Some(weekday);
            Ok(self)
        }
    }

    pub fn with_month(mut self, month: u8) -> Result<Self, LaunchdError> {
        return if month > 12 {
            Err(LaunchdError::CalendarIntervalError(CalendarIntervalField::Month, month))
        } else {
            self.month = Some(month);
            Ok(self)
        }
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
