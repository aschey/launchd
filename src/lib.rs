use std::path::Path;
#[cfg(feature="cron")]
use std::convert::TryInto;
#[cfg(feature="serde")]
use serde::Serialize;
#[cfg(feature="xml")]
use plist::{to_writer_xml, to_file_xml};
#[cfg(feature="cron")]
use cron::{Schedule, TimeUnitSpec};

/// Representation of a launchd.plist file.
/// The definition of which can be found [here](https://www.manpagez.com/man/5/launchd.plist/).
/// 
/// Usage:
/// ```
/// use launchd::{Launchd, LaunchdError, CalendarInterval};
/// use std::path::Path;
/// 
/// fn example() -> Result<Launchd, LaunchdError> {
///     Ok(Launchd::new(String::from("LABEL"), Path::new("./foo/bar.txt"))
///         ?.with_user_name("Henk".to_owned())
///         .with_program_arguments(vec!["Hello".to_owned(), "World!".to_owned()])
///         .with_start_calendar_intervals(vec![CalendarInterval::new().with_hour(12)?])
///         .disabled()
///         // etc...
///     )
/// }
/// 
/// let launchd = example();
///     
/// ```
/// This will create a launchd representation with the label "LABEL", running "./foo/bar.txt" 
/// with the args "Hello" and "World!", for the user "Henk", each day at 12.
/// 
/// NB: The usage is still subject to change.
// TODO: Fill with all options in https://www.manpagez.com/man/5/launchd.plist/
// TODO: remove owning Strings
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "xml", serde(rename_all = "PascalCase"))]
pub struct Launchd {
    label: String,
    disabled: Option<bool>,
    user_name: Option<String>,
    group_name: Option<String>,
    // inetdCompatibility: Option<(?)>,
    // LimitLoadToHosts: Option<Vec<String>>,
    // LimitLoadFromHosts: Option<Vec<String>>,
    // LimitLoadToSessionType: Option<String>,
    program: String,
    program_arguments: Option<Vec<String>>,
    // EnableGlobbing: Option<bool>,
    // EnableTransactions: Option<bool>,
    // OnDemand: Option<bool>, NB: deprecated (see KeepAlive)
    // KeepAlive: Option<(?)>,
    run_at_load: Option<bool>,
    // RootDirectory: Option<String>, NB: from path
    // WorkingDirectory: Option<String>, NB: from path
    // EnvironmentVariables: Option<String>
    // Unmask: Option<u32> NB: check mode_t size in <sys/types.h>
    // TimeOut: Option<u32>
    // ExitTimeOut: Option<u32>
    // ThrottleInterval: Option<u32>
    // InitGroups: Option<bool>
    watch_paths: Option<Vec<String>>,
    queue_directories: Option<Vec<String>>,
    start_on_mount: Option<bool>,
    start_interval: Option<u32>,
    start_calendar_intervals: Option<Vec<CalendarInterval>>,
    // StandardInPath: Option<String> NB: from path
    // StandardOutPath: Option<String> NB: from path
    // StandardErrorPath: Option<String> NB: from path
    // ...
}

#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "xml", serde(rename_all = "PascalCase"))]
#[derive(Copy, Clone)]
pub struct CalendarInterval {
    minute: Option<u8>,
    hour: Option<u8>,
    day: Option<u8>,
    weekday: Option<u8>,
    month: Option<u8>,
    #[serde(skip_serializing)]
    initialized: bool,
}

// TODO implement debug
#[derive(Debug)]
pub enum LaunchdError {
    CalendarIntervalError(CalendarIntervalField, u8),
    #[cfg(feature="cron")]
    CronParseError(CalendarIntervalField, u32), // TODO: Change u32 to cron::Ordinal when possible
    PathConversionError,
}

#[derive(Debug)]
pub enum CalendarIntervalField {
    Minute,
    Hour,
    Day,
    Weekday,
    Month,
}

// TODO: This can be generated by a macro (maybe derive_builder?)
impl Launchd {
    pub fn new(label: String, program: &Path) -> Result<Self, LaunchdError> {
        let pathstr = program.to_str().ok_or(LaunchdError::PathConversionError)?.to_owned();
        Ok(Launchd {
            label: label,
            disabled: None,
            user_name: None,
            group_name: None,
            program: pathstr,
            program_arguments: None,
            run_at_load: None,
            watch_paths: None,
            queue_directories: None,
            start_on_mount: None,
            start_interval: None,
            start_calendar_intervals: None,
        })
    }

    pub fn with_label(mut self, label: String) -> Self {
        self.label = label;
        self
    }

    pub fn with_disabled(mut self, disabled: bool) -> Self{
        self.disabled = Some(disabled);
        self
    }

    pub fn disabled(self) -> Self {
        self.with_disabled(true)
    }

   pub fn with_user_name(mut self, user_name: String) -> Self {
       self.user_name = Some(user_name);
       self
   }

   pub fn with_group_name(mut self, group_name: String) -> Self {
       self.group_name = Some(group_name);
       self
   }

   pub fn with_program(mut self, program: &Path) -> Result<Self, LaunchdError> {
       let pathstr = program.to_str().ok_or(LaunchdError::PathConversionError)?.to_owned();
       self.program = pathstr;
       Ok(self)
   }

    pub fn with_program_arguments(mut self, program_arguments: Vec<String>) -> Self {
        self.program_arguments = Some(program_arguments);
        self
    }

    pub fn run_at_load(mut self) -> Self {
        self.run_at_load = Some(true);
        self
    }

    pub fn with_run_at_load(mut self, run_at_load: bool) -> Self {
        self.run_at_load = Some(run_at_load);
        self
    }

    pub fn with_queue_directories(
        mut self, 
        queue_directories: Vec<String>
    ) -> Self {
        self.queue_directories = Some(queue_directories);
        self
    }

    pub fn with_watch_paths(mut self, watch_paths: Vec<String>) -> Self {
        self.watch_paths = Some(watch_paths);
        self
    }

    pub fn with_start_on_mount(mut self, start_on_mount: bool) -> Self {
        self.start_on_mount = Some(start_on_mount);
        self
    }

    pub fn start_on_mount(self) -> Self {
        self.with_start_on_mount(true)
    }

    pub fn with_start_interval(mut self, start_interval: u32) -> Self {
        self.start_interval = Some(start_interval);
        self
    }

    pub fn with_start_calendar_intervals(mut self, start_calendar_intervals: Vec<CalendarInterval>) -> Self {
        self.start_calendar_intervals = Some(start_calendar_intervals);
        self
    }

    // Write --
    #[cfg(feature="xml")]
    pub fn to_writer_xml<W: std::io::Write>(&self, writer: W) -> Result<(), plist::Error>{
        to_writer_xml(writer, self)
    }

    #[cfg(feature="xml")]
    pub fn to_file_xml<P: AsRef<Path>>(&self, file: P) -> Result<(), plist::Error>{
        to_file_xml(file, self)
    }
}

/// Representation of a CalendarInterval
/// 
/// Usage:
/// ```
/// use launchd::{CalendarInterval, LaunchdError};
/// fn example() -> Result<CalendarInterval, LaunchdError> {
///     CalendarInterval::new()
///             .with_hour(12)
///             ?.with_minute(10)
///             ?.with_weekday(7)
/// }
/// 
/// let calendarinterval = example();
/// ```
/// 

impl CalendarInterval {
    pub fn new() -> Self {
        CalendarInterval {
            minute: None,
            hour: None,
            day: None,
            weekday: None,
            month: None,
            initialized: false
        }
    }

    pub fn with_minute(self, minute: u8) -> Result<Self, LaunchdError> {
        return if minute > 60 {
            Err(LaunchdError::CalendarIntervalError(CalendarIntervalField::Minute, minute))
        } else {
            let mut result = self;
            result.minute = Some(minute);
            result.initialized = true;
            Ok(result)
        }
    }

    pub fn with_hour(self, hour: u8) -> Result<Self, LaunchdError> {
        return if hour > 60 {
            Err(LaunchdError::CalendarIntervalError(CalendarIntervalField::Hour, hour))
        } else {
            let mut result = self;
            result.hour = Some(hour);
            result.initialized = true;
            Ok(result)
        }
    }

    pub fn with_day(self, day: u8) -> Result<Self, LaunchdError> {
        return if day > 31 {
            Err(LaunchdError::CalendarIntervalError(CalendarIntervalField::Day, day))
        } else {
            let mut result = self;
            result.day = Some(day);
            result.initialized = true;
            Ok(result)
        }
    }

    pub fn with_weekday(self, weekday: u8) -> Result<Self, LaunchdError> {
        return if weekday > 7 {
            Err(LaunchdError::CalendarIntervalError(CalendarIntervalField::Weekday, weekday))
        } else {
            let mut result = self;
            result.weekday = Some(weekday);
            result.initialized = true;
            Ok(result)
        }
    }

    pub fn with_month(self, month: u8) -> Result<Self, LaunchdError> {
        return if month > 12 {
            Err(LaunchdError::CalendarIntervalError(CalendarIntervalField::Month, month))
        } else {
            let mut result = self;
            result.month = Some(month);
            result.initialized = true;
            Ok(result)
        }
    }

    #[cfg(feature="cron")]
    pub fn from_cron_schedule(schedule: Schedule) -> Result<Vec<Self>, LaunchdError> {
        let mut result_vec = Vec::new();
        for month in schedule.months().iter() {
            for weekday in schedule.days_of_week().iter() {
                for day in schedule.days_of_month().iter() {
                    for hour in schedule.hours().iter() {
                        for minute in schedule.minutes().iter() {

                            let result = Self::new();

                            // TODO: clean this mess up (thiserror + anyhow ?)
                            if !schedule.months().is_all() { 
                                result.with_month(
                                    month.try_into().map_err(|_| 
                                        LaunchdError::CronParseError(CalendarIntervalField::Month, month) 
                                    )?
                                )?; 
                            }
                            if !schedule.days_of_week().is_all() { 
                                result.with_weekday(
                                    weekday.try_into().map_err(|_| 
                                        LaunchdError::CronParseError(CalendarIntervalField::Weekday, weekday) 
                                    )?
                                )?; 
                            }
                            if !schedule.days_of_month().is_all() { 
                                result.with_day(
                                    day.try_into().map_err(|_| 
                                        LaunchdError::CronParseError(CalendarIntervalField::Day, day) 
                                    )?
                                )?; 
                            }
                            if !schedule.hours().is_all() { 
                                result.with_hour(
                                    hour.try_into().map_err(|_| 
                                        LaunchdError::CronParseError(CalendarIntervalField::Hour, hour) 
                                    )?
                                )?; 
                            }
                            if !schedule.minutes().is_all() { 
                                result.with_minute(
                                    minute.try_into().map_err(|_| 
                                        LaunchdError::CronParseError(CalendarIntervalField::Minute, minute) 
                                    )?
                                )?; 
                            }

                            if result.initialized { result_vec.push(result); }

                            if schedule.minutes().is_all() { break;}
                        }
                        if schedule.hours().is_all() { break; }
                    }
                    if schedule.days_of_month().is_all() { break; }
                }
                if schedule.days_of_week().is_all() {break;}
            }
            if schedule.months().is_all() { break; }
        }
        Ok(result_vec)
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
